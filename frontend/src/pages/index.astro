---
// Disable prerendering for this page - it needs to handle POST requests and make API calls at runtime
export const prerender = false;

import Layout from '../layouts/Layout.astro';
import Modal from '../components/Modal.astro';
import MessageBanner from '../components/MessageBanner.astro';
import TabNavigation from '../components/TabNavigation.astro';
import SubmitVotesTab from '../components/SubmitVotesTab.astro';
import HistoryTab from '../components/HistoryTab.astro';
import CalculateSeatsTab from '../components/CalculateSeatsTab.astro';
import ClearSubmissionsTab from '../components/ClearSubmissionsTab.astro';
import CalculationResults from '../components/CalculationResults.astro';
import TabSwitchingScript from '../components/TabSwitchingScript.astro';
import { DhondtApiService } from '../services/api';
import { PREDEFINED_PARTIES, TABS, FORM_ACTIONS, type TabType } from '../utils/constants';
import type { ListInput, CalculationHistoryItem, CalculationResult } from '../types/dhondt';
import { getBackendUrl } from '../utils/env';

// State variables
let submitResult = null;
let aggregateResult: CalculationResult | null = null;
let aggregatedVotes = null;
let calculationHistory: CalculationHistoryItem[] | null = null;
let error = null;
let successMessage = null;
let activeTab: TabType = TABS.SUBMIT; // Default active tab

// Get backend URLs
const serverBackendUrl = getBackendUrl(); // For server-side API calls (uses http://backend:5000)
const backendUrl = import.meta.env.PUBLIC_BACKEND_URL || 'http://localhost:5000'; // For client-side use

// Handle form submissions
if (Astro.request.method === 'POST') {
  try {
    const formData = await Astro.request.formData();
    const action = formData.get('action') as string;

    if (action === FORM_ACTIONS.SUBMIT_VOTES) {
      // Submit votes to database for aggregation
      const lists: ListInput[] = [];

      // Iterate through predefined parties
      for (const partyName of PREDEFINED_PARTIES) {
        const votes = formData.get(`party_${partyName}`) as string;

        if (votes && parseInt(votes) > 0) {
          lists.push({
            name: partyName,
            votes: parseInt(votes)
          });
        }
      }

      if (lists.length === 0) {
        error = 'Por favor ingrese al menos una lista con votos';
      } else {
        // Submit votes using direct backend call (server-side)
        console.log('[SSR] Submitting votes to:', `${serverBackendUrl}/submit-votes`);

        const response = await fetch(`${serverBackendUrl}/submit-votes`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ lists })
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.detail || 'Failed to submit votes');
        }

        submitResult = await response.json();
        successMessage = submitResult.message;
        console.log('[SSR] Votes submitted successfully:', submitResult);

        // Switch to history tab after successful submission
        // Data will be loaded by the code below
        activeTab = TABS.HISTORY;
      }
    } else if (action === FORM_ACTIONS.CALCULATE_AGGREGATE) {
      // Calculate D'Hondt on aggregate data
      const totalSeats = parseInt(formData.get('totalSeats') as string);

      if (totalSeats <= 0) {
        error = 'El total de escaños debe ser mayor que 0';
        activeTab = TABS.CALCULATE;
      } else {
        // Calculate using direct backend call (server-side)
        const response = await fetch(`${serverBackendUrl}/calculate-aggregate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ total_seats: totalSeats, save_result: true })
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.detail || 'Failed to calculate aggregate');
        }

        aggregateResult = await response.json();
        successMessage = 'Cálculo completado exitosamente';
        activeTab = TABS.CALCULATE;

        // Calculation history will be loaded by the code below
      }
    } else if (action === FORM_ACTIONS.CLEAR_SUBMISSIONS) {
      // Clear all submissions using direct backend call (server-side)
      const response = await fetch(`${serverBackendUrl}/clear-submissions`, {
        method: 'DELETE'
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || 'Failed to clear submissions');
      }

      const clearResult = await response.json();
      successMessage = clearResult.message;
      // Don't set to null - let the data refresh logic below handle it
      // This ensures the "empty state" is properly displayed
      activeTab = TABS.CLEAR;
    }
  } catch (e: any) {
    // Enhanced error handling with backend URL context
    console.error('[SSR] Error during form submission:', e);

    // Check if it's a fetch/network error
    if (e.name === 'TypeError' && e.message.includes('fetch')) {
      error = `Error de conexión: No se pudo conectar al backend en ${serverBackendUrl}. Verifica que el backend esté corriendo.`;
    } else {
      error = `Error: ${e.message}`;
    }
  }
}

// Always load aggregated votes after POST operations or on initial page load
// This ensures data is always fresh and tabs display correctly
// NOTE: Server-side code must use absolute URLs with the backend service URL
if (!error) {
  try {
    const response = await fetch(`${serverBackendUrl}/aggregated-votes`);
    if (response.ok) {
      aggregatedVotes = await response.json();
      console.log('[SSR] Loaded aggregated votes:', aggregatedVotes);
    } else {
      const errorData = await response.json();
      console.log('[SSR] No aggregated votes yet:', errorData.detail);
      aggregatedVotes = null; // Explicitly set to null when no data
    }
  } catch (e: any) {
    console.error('[SSR] Failed to load aggregated votes:', e.message);
    aggregatedVotes = null;
  }
}

// Always load calculation history after POST operations or on initial page load
// This ensures the history tab always shows the latest data
if (!error) {
  try {
    const response = await fetch(`${serverBackendUrl}/calculation-history?limit=20`);
    if (response.ok) {
      calculationHistory = await response.json();
      console.log('[SSR] Loaded calculation history:', calculationHistory?.length || 0, 'items');
    } else {
      const errorData = await response.json();
      console.log('[SSR] No calculation history yet:', errorData.detail);
      calculationHistory = null;
    }
  } catch (e: any) {
    console.error('[SSR] Failed to load calculation history:', e.message);
    calculationHistory = null;
  }
}
---

<Layout title="Calculadora D'Hondt - Votación Agregada">

  <MessageBanner error={error} successMessage={successMessage} />

  {/* Tab Navigation and Content */}
  <div class="tabs-container">
    <TabNavigation activeTab={activeTab} />

    <div class="tabs-content">
      <SubmitVotesTab
        isActive={activeTab === TABS.SUBMIT}
        predefinedParties={[...PREDEFINED_PARTIES]}
      />

      <HistoryTab
        isActive={activeTab === TABS.HISTORY}
        aggregatedVotes={aggregatedVotes}
        calculationHistory={calculationHistory}
        backendUrl={backendUrl}
      />

      <CalculateSeatsTab
        isActive={activeTab === TABS.CALCULATE}
        aggregatedVotes={aggregatedVotes}
      />

      <ClearSubmissionsTab
        isActive={activeTab === TABS.CLEAR}
        aggregatedVotes={aggregatedVotes}
      />
    </div>
  </div>

  {/* Modal for Results */}
  <Modal id="resultsModal">
    <div id="modalResults">
      {aggregateResult && <CalculationResults result={aggregateResult} />}
    </div>
  </Modal>

  {/* Chart.js Library */}
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  {/* Tab Switching Logic */}
  <TabSwitchingScript />

  {/* Modal Logic */}
  <script is:inline define:vars={{ hasResult: !!aggregateResult }}>
    // Wait for DOM and modal functions to be ready
    function waitForModal() {
      if (typeof window.initModal === 'function' && typeof window.openModal === 'function') {
        // Initialize modal
        window.initModal('resultsModal');

        // Auto-open modal if results exist
        if (hasResult) {
          setTimeout(() => {
            window.openModal('resultsModal');
          }, 100);
        }
      } else {
        // Retry after a short delay if functions not ready yet
        setTimeout(waitForModal, 50);
      }
    }

    // Start waiting for modal functions when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', waitForModal);
    } else {
      // DOM already loaded
      waitForModal();
    }

    // Re-initialize after Astro View Transitions navigation
    document.addEventListener('astro:page-load', waitForModal);
  </script>

  <style>
    /* Tabs Container */
    .tabs-container {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    /* Tab Content */
    .tabs-content {
      position: relative;
      min-height: 400px;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .tabs-content {
        min-height: 300px;
      }
    }
  </style>
</Layout>
